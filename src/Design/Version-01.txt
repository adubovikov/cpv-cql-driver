CqlSessionConfiguration [Common, byvalue]
	setMaxPoolSize()
	setDnsCacheTime()

CqlNodeConfiguration [Common, byvalue]
	setAddress(hostname, port)
	setUseSsl()
	setUseCompression()
	setPasswordAuthentication(username, password)
	...
	getIpAddress(ipAddress, dnsCacheTime)
	updateIpAddress(ipAddress)

CqlNodeCollection [Common, shared_ptr]
	chooseOneNode()
	reportFailure(nodeConfiguration)
	reportSuccess(nodeConfiguration)
	create(initialNodes)

CqlSessionFactory [HighLevel, shared_ptr]
	getSession()
	create(sessionConfiguration, nodeCollection)

CqlSession [HighLevel, CqlObject]
	query(statement, parameters...) -> CqlObject<CqlResultSet>
	execute(statement, parameters...) -> void
	batchExecute(statement, listOfParameters) -> void

CqlConnectionPool [LowLevel, shared_ptr]
	getConnection()
	CqlConnectionPool(sessionConfiguration, nodeCollection)

CqlConnectionInfo [LowLevel, byvalue]
	getVersion()
	getHeaderSize()
	getMaximumMessageBodySize()
	getCompressor()
	useVersion()
	useCompressor(compressor)

CqlConnection [LowLevel, shared_ptr]
	CqlConnection(sessionConfiguration, nodeConfiguration)

==========================================

auto factory = CqlSessionFactory.create(
	CqlSessionConfiguration()
		.setMaxPoolSize(100)
		.setDnsCacheTime(std::chrono::milliseconds(15000)),
	CqlNodeCollection.create({
		CqlNodeConfiguration()
			.setUseAddress("127.0.0.1")
			.setUseSsl(true)
			.setUseCompression(true)
			.setPasswordAuthentication("abc", "123456"),
		CqlNodeConfiguration()
			.setUseAddress("127.0.0.1")
			.setUseSsl(true)
			.setUseCompression(true)
			.setPasswordAuthentication("abc", "123456")
	}));
auto session = factory.getSession();

==========================================

CqlConnection
	sendMessage(message)
		push message to queue
		set promise to promises[streamId]
		start sender if not started
		wait future

	startSender()
		repeat while queue not empty
			take message from queue
			send message
			resolve promises[streamId]
		set sender started flag to false
		# no race condition here because it's single thread

	waitNextMessage(stream)
		take message from queue
		if not success
			add wait count
			set promise to promises[streamId]
			start receiver if not started
			wait future
			take message from queue

	startReceiver()
		repeat while wait count > 0
			receive one message and push to queue
			if promises[streamId]
				resolve promises[streamId]
				reduce wait count
		set receiver started flag to false
		# no race condition here, same as above

==========================================

CqlConnectionPool
	makeConnection()
		select node from CqlNodeCollection
		make connection from node
		connections.emplace_back(connection)
		return connection

	tryGetConnection()
		find connection with smallest stream count
		stream = connection.getStream()
		if stream.isValid()
			return (connection, stream)

	getConnection()
		if connection count < min pool size
			makeConnection()
			stream = connection.getStream()
			assert stream.isValid()
			return (connection, stream)
		connection, stream = tryGetConnection()
		if ok
			return (connection, stream)
		if connection count < max pool size
			makeConnection()
			stream = connection.getStream()
			assert stream.isValid()
			return (connection, stream)
		make promise
		push promise to waiting queue
		connection, stream = wait future
		return (connection, stream)

	notifyConnectionBecomeIdle(connection)
		stream = connection.getStream()
		assert stream.isValid()
		take promise from queue and set value

	findConnectionBecomeIdleTimer()
		sleep sometime
		if waiting queue not empty
			connection, stream = tryGetConnection()
			if ok
				take promise from queue and set value
		if waiting queue not empty
			findConnectionBecomeIdleTimer()

